var documenterSearchIndex = {"docs":
[{"location":"guide/options/#Configuration-Options","page":"Configuration Options","title":"Configuration Options","text":"This guide covers all configuration options for encoding and decoding.","category":"section"},{"location":"guide/options/#EncodeOptions","page":"Configuration Options","title":"EncodeOptions","text":"Configure encoding behavior with EncodeOptions:\n\noptions = ToonFormat.EncodeOptions(\n    indent = 2,\n    delimiter = ToonFormat.COMMA,\n    keyFolding = \"off\",\n    flattenDepth = typemax(Int)\n)\n\nToonFormat.encode(data, options=options)","category":"section"},{"location":"guide/options/#indent","page":"Configuration Options","title":"indent","text":"Number of spaces per indentation level.\n\nType: Int   Default: 2   Valid values: Any positive integer\n\n# 2 spaces (default)\noptions = ToonFormat.EncodeOptions(indent=2)\n\n# 4 spaces\noptions = ToonFormat.EncodeOptions(indent=4)\n\n# 8 spaces\noptions = ToonFormat.EncodeOptions(indent=8)","category":"section"},{"location":"guide/options/#delimiter","page":"Configuration Options","title":"delimiter","text":"Delimiter character for arrays.\n\nType: Delimiter   Default: ToonFormat.COMMA   Valid values: ToonFormat.COMMA, ToonFormat.TAB, ToonFormat.PIPE\n\n# Comma (default)\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.COMMA)\n# Output: [3]: 1,2,3\n\n# Tab\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\n# Output: [3\t]: 1\t2\t3\n\n# Pipe\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.PIPE)\n# Output: [3|]: 1|2|3\n\nUse cases:\n\nComma: General purpose, most compact\nTab: TSV-like data, easy to parse\nPipe: Visual separation, database-style","category":"section"},{"location":"guide/options/#keyFolding","page":"Configuration Options","title":"keyFolding","text":"Enable flattening of nested objects into dotted keys.\n\nType: String   Default: \"off\"   Valid values: \"off\", \"safe\"\n\ndata = Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => 42)))\n\n# Off (default) - no folding\noptions = ToonFormat.EncodeOptions(keyFolding=\"off\")\nToonFormat.encode(data, options=options)\n# a:\n#   b:\n#     c: 42\n\n# Safe - fold identifier keys only\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\")\nToonFormat.encode(data, options=options)\n# a.b.c: 42\n\nSafe mode rules:\n\nOnly folds keys that are valid identifiers\nKeys must match pattern: ^[A-Za-z_][A-Za-z0-9_]*$\nKeys with spaces, special chars, or starting with numbers are not folded","category":"section"},{"location":"guide/options/#flattenDepth","page":"Configuration Options","title":"flattenDepth","text":"Maximum depth for key folding.\n\nType: Int   Default: typemax(Int) (unlimited)   Valid values: Any non-negative integer\n\ndata = Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => Dict(\"d\" => 42))))\n\n# Unlimited depth (default)\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\")\nToonFormat.encode(data, options=options)\n# a.b.c.d: 42\n\n# Limit to 2 levels\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\", flattenDepth=2)\nToonFormat.encode(data, options=options)\n# a.b:\n#   c:\n#     d: 42","category":"section"},{"location":"guide/options/#DecodeOptions","page":"Configuration Options","title":"DecodeOptions","text":"Configure decoding behavior with DecodeOptions:\n\noptions = ToonFormat.DecodeOptions(\n    indent = 2,\n    strict = true,\n    expandPaths = \"off\"\n)\n\nToonFormat.decode(input, options=options)","category":"section"},{"location":"guide/options/#indent-2","page":"Configuration Options","title":"indent","text":"Expected number of spaces per indentation level.\n\nType: Int   Default: 2   Valid values: Any positive integer\n\n# 2 spaces (default)\noptions = ToonFormat.DecodeOptions(indent=2)\n\n# 4 spaces\noptions = ToonFormat.DecodeOptions(indent=4)\n\nNote: Must match the indentation used in the input.","category":"section"},{"location":"guide/options/#strict","page":"Configuration Options","title":"strict","text":"Enable strict validation.\n\nType: Bool   Default: true   Valid values: true, false\n\n# Strict mode (default) - validates everything\noptions = ToonFormat.DecodeOptions(strict=true)\n\n# Non-strict mode - lenient parsing\noptions = ToonFormat.DecodeOptions(strict=false)\n\nStrict mode validates:\n\nArray count matches declared length\nRow width matches field count in tabular arrays\nColons present after keys and array headers\nOnly valid escape sequences (\\\\, \\\", \\n, \\r, \\t)\nNo unterminated strings\nIndentation is exact multiple of indent\nNo tabs in indentation\nNo blank lines inside arrays\nNo path expansion conflicts\n\nNon-strict mode:\n\nAccepts actual array length if different from declared\nAccepts variable row widths\nMore lenient with formatting\nUses last-write-wins for conflicts","category":"section"},{"location":"guide/options/#expandPaths","page":"Configuration Options","title":"expandPaths","text":"Enable expansion of dotted keys into nested objects.\n\nType: String   Default: \"off\"   Valid values: \"off\", \"safe\"\n\ninput = \"a.b.c: 42\"\n\n# Off (default) - no expansion\noptions = ToonFormat.DecodeOptions(expandPaths=\"off\")\nToonFormat.decode(input, options=options)\n# Dict(\"a.b.c\" => 42)\n\n# Safe - expand identifier keys only\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\")\nToonFormat.decode(input, options=options)\n# Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => 42)))\n\nSafe mode rules:\n\nOnly expands keys where all segments are valid identifiers\nSegments must match pattern: ^[A-Za-z_][A-Za-z0-9_]*$\nDetects conflicts (e.g., a: 1 followed by a.b: 2)\nIn strict mode, errors on conflicts\nIn non-strict mode, uses last-write-wins","category":"section"},{"location":"guide/options/#Common-Configurations","page":"Configuration Options","title":"Common Configurations","text":"","category":"section"},{"location":"guide/options/#Production-(Strict)","page":"Configuration Options","title":"Production (Strict)","text":"encode_opts = ToonFormat.EncodeOptions(\n    indent = 2,\n    delimiter = ToonFormat.COMMA\n)\n\ndecode_opts = ToonFormat.DecodeOptions(\n    indent = 2,\n    strict = true\n)","category":"section"},{"location":"guide/options/#Development-(Lenient)","page":"Configuration Options","title":"Development (Lenient)","text":"decode_opts = ToonFormat.DecodeOptions(\n    strict = false\n)","category":"section"},{"location":"guide/options/#Compact-(Key-Folding)","page":"Configuration Options","title":"Compact (Key Folding)","text":"encode_opts = ToonFormat.EncodeOptions(\n    keyFolding = \"safe\",\n    flattenDepth = 3\n)\n\ndecode_opts = ToonFormat.DecodeOptions(\n    expandPaths = \"safe\"\n)","category":"section"},{"location":"guide/options/#TSV-like-(Tab-Delimiter)","page":"Configuration Options","title":"TSV-like (Tab Delimiter)","text":"encode_opts = ToonFormat.EncodeOptions(\n    delimiter = ToonFormat.TAB\n)","category":"section"},{"location":"guide/options/#Custom-Indentation","page":"Configuration Options","title":"Custom Indentation","text":"encode_opts = ToonFormat.EncodeOptions(indent=4)\ndecode_opts = ToonFormat.DecodeOptions(indent=4)","category":"section"},{"location":"guide/options/#Round-trip-Compatibility","page":"Configuration Options","title":"Round-trip Compatibility","text":"For perfect round-trips, use matching options:\n\n# Encoding\nencode_opts = ToonFormat.EncodeOptions(\n    indent = 4,\n    keyFolding = \"safe\"\n)\nencoded = ToonFormat.encode(data, options=encode_opts)\n\n# Decoding\ndecode_opts = ToonFormat.DecodeOptions(\n    indent = 4,\n    expandPaths = \"safe\"\n)\ndecoded = ToonFormat.decode(encoded, options=decode_opts)\n\n# data == decoded (structurally equivalent)","category":"section"},{"location":"guide/options/#Next-Steps","page":"Configuration Options","title":"Next Steps","text":"Learn about Encoding\nLearn about Decoding\nSee Advanced Features","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for ToonFormat.jl.","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#encode","page":"API Reference","title":"encode","text":"encode(value; options::EncodeOptions=EncodeOptions()) -> String\n\nEncode a Julia value to TOON format string.\n\nArguments:\n\nvalue: Any Julia value (will be normalized to JSON model)\noptions: Optional encoding configuration\n\nReturns: TOON formatted string\n\nExample:\n\ndata = Dict(\"name\" => \"Alice\", \"age\" => 30)\ntoon_str = ToonFormat.encode(data)","category":"section"},{"location":"api/#decode","page":"API Reference","title":"decode","text":"decode(input::String; options::DecodeOptions=DecodeOptions()) -> JsonValue\n\nDecode a TOON format string to a Julia value.\n\nArguments:\n\ninput: TOON formatted string\noptions: Optional decoding configuration\n\nReturns: Parsed Julia value (Dict, Array, or primitive)\n\nExample:\n\ninput = \"name: Alice\\nage: 30\"\ndata = ToonFormat.decode(input)","category":"section"},{"location":"api/#Configuration-Types","page":"API Reference","title":"Configuration Types","text":"","category":"section"},{"location":"api/#EncodeOptions","page":"API Reference","title":"EncodeOptions","text":"EncodeOptions(;\n    indent::Int = 2,\n    delimiter::Delimiter = COMMA,\n    keyFolding::String = \"off\",\n    flattenDepth::Int = typemax(Int)\n)\n\nConfiguration for encoding behavior.\n\nFields:\n\nindent::Int: Number of spaces per indentation level (default: 2)\ndelimiter::Delimiter: Delimiter for arrays - COMMA, TAB, or PIPE (default: COMMA)\nkeyFolding::String: Key folding mode - \"off\" or \"safe\" (default: \"off\")\nflattenDepth::Int: Maximum folding depth (default: unlimited)\n\nExample:\n\noptions = ToonFormat.EncodeOptions(\n    indent = 4,\n    delimiter = ToonFormat.TAB,\n    keyFolding = \"safe\",\n    flattenDepth = 2\n)","category":"section"},{"location":"api/#DecodeOptions","page":"API Reference","title":"DecodeOptions","text":"DecodeOptions(;\n    indent::Int = 2,\n    strict::Bool = true,\n    expandPaths::String = \"off\"\n)\n\nConfiguration for decoding behavior.\n\nFields:\n\nindent::Int: Expected spaces per indentation level (default: 2)\nstrict::Bool: Enable strict validation (default: true)\nexpandPaths::String: Path expansion mode - \"off\" or \"safe\" (default: \"off\")\n\nExample:\n\noptions = ToonFormat.DecodeOptions(\n    indent = 4,\n    strict = true,\n    expandPaths = \"safe\"\n)","category":"section"},{"location":"api/#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"api/#Delimiters","page":"API Reference","title":"Delimiters","text":"COMMA::Delimiter    # \",\"\nTAB::Delimiter      # \"\\t\"\nPIPE::Delimiter     # \"|\"\n\nDelimiter constants for array encoding.\n\nExample:\n\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)","category":"section"},{"location":"api/#Escape-Sequences","page":"API Reference","title":"Escape Sequences","text":"BACKSLASH = \"\\\\\\\\\"   # \\\\\nDOUBLE_QUOTE = \"\\\\\"\" # \\\"\nNEWLINE = \"\\\\n\"      # \\n\nCARRIAGE_RETURN = \"\\\\r\"  # \\r\nTAB_ESCAPE = \"\\\\t\"   # \\t\n\nValid escape sequences in TOON strings.","category":"section"},{"location":"api/#Type-Aliases","page":"API Reference","title":"Type Aliases","text":"","category":"section"},{"location":"api/#JsonValue","page":"API Reference","title":"JsonValue","text":"JsonValue = Union{JsonObject, JsonArray, JsonPrimitive}\n\nAny valid JSON value type.","category":"section"},{"location":"api/#JsonObject","page":"API Reference","title":"JsonObject","text":"JsonObject = Dict{String, JsonValue}\n\nJSON object (dictionary with string keys).","category":"section"},{"location":"api/#JsonArray","page":"API Reference","title":"JsonArray","text":"JsonArray = Vector{JsonValue}\n\nJSON array (vector of values).","category":"section"},{"location":"api/#JsonPrimitive","page":"API Reference","title":"JsonPrimitive","text":"JsonPrimitive = Union{String, Number, Bool, Nothing}\n\nJSON primitive types (string, number, boolean, null).","category":"section"},{"location":"api/#Internal-Types","page":"API Reference","title":"Internal Types","text":"These types are used internally but may be useful for advanced usage.","category":"section"},{"location":"api/#LineWriter","page":"API Reference","title":"LineWriter","text":"mutable struct LineWriter\n    lines::Vector{String}\nend\n\nHelper for building multi-line output during encoding.\n\nMethods:\n\npush!(writer, depth, content): Add a line at specified depth","category":"section"},{"location":"api/#LineCursor","page":"API Reference","title":"LineCursor","text":"mutable struct LineCursor\n    lines::Vector{ParsedLine}\n    position::Int\n    blankLines::Vector{BlankLine}\nend\n\nHelper for parsing multi-line input during decoding.\n\nMethods:\n\npeek(cursor): Look at current line without advancing\nadvance!(cursor): Move to next line\nhas_more(cursor): Check if more lines available","category":"section"},{"location":"api/#ParsedLine","page":"API Reference","title":"ParsedLine","text":"struct ParsedLine\n    content::String\n    depth::Int\n    lineNumber::Int\nend\n\nRepresents a parsed line with indentation information.","category":"section"},{"location":"api/#ArrayHeader","page":"API Reference","title":"ArrayHeader","text":"struct ArrayHeader\n    length::Int\n    delimiter::Delimiter\n    fields::Union{Vector{String}, Nothing}\nend\n\nParsed array header information.\n\nFields:\n\nlength: Declared array length\ndelimiter: Active delimiter for this array\nfields: Field names for tabular arrays (or nothing)","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#normalize","page":"API Reference","title":"normalize","text":"normalize(value) -> JsonValue\n\nNormalize a Julia value to the JSON data model.\n\nTransformations:\n\nNaN, Inf, -Inf → nothing (null)\n-0.0 → 0.0\nDictionaries → JsonObject\nArrays → JsonArray\nOther types → primitives\n\nExample:\n\nToonFormat.normalize(NaN)  # nothing\nToonFormat.normalize(-0.0)  # 0.0","category":"section"},{"location":"api/#is*tabular*array","page":"API Reference","title":"istabulararray","text":"is_tabular_array(arr::Vector) -> Bool\n\nCheck if an array can be encoded in tabular format.\n\nRequirements:\n\nAll elements are objects (dictionaries)\nAll objects have the same keys\nAll keys are strings\n\nExample:\n\narr = [Dict(\"a\" => 1, \"b\" => 2), Dict(\"a\" => 3, \"b\" => 4)]\nToonFormat.is_tabular_array(arr)  # true","category":"section"},{"location":"api/#needs_quoting","page":"API Reference","title":"needs_quoting","text":"needs_quoting(s::String, delimiter::Delimiter) -> Bool\n\nCheck if a string needs to be quoted.\n\nQuoting required for:\n\nEmpty strings\nStrings with whitespace\nReserved literals (true, false, null)\nNumeric-like strings\nStrings with special characters\nStrings containing the active delimiter\n\nExample:\n\nToonFormat.needs_quoting(\"hello\", ToonFormat.COMMA)  # false\nToonFormat.needs_quoting(\"hello world\", ToonFormat.COMMA)  # true\nToonFormat.needs_quoting(\"true\", ToonFormat.COMMA)  # true","category":"section"},{"location":"api/#Error-Types","page":"API Reference","title":"Error Types","text":"ToonFormat.jl throws ErrorException with descriptive messages for various error conditions:\n\nArray count mismatch: \"Array length mismatch: expected X, got Y\"\nRow width mismatch: \"Row width mismatch at line X: expected Y fields, got Z\"\nMissing colon: \"Missing colon after key at line X\"\nInvalid escape: \"Invalid escape sequence: \\X\"\nUnterminated string: \"Unterminated string at line X\"\nIndentation error: \"Indentation must be a multiple of X spaces (line Y)\"\nTab in indentation: \"Tabs are not allowed in indentation (line X)\"\nBlank line error: \"Blank lines are not allowed inside arrays (line X)\"\nPath conflict: \"Cannot expand path 'X': segment 'Y' already exists as non-object\"","category":"section"},{"location":"api/#Version-Information","page":"API Reference","title":"Version Information","text":"ToonFormat.version  # Package version\n\nGet the current version of ToonFormat.jl.","category":"section"},{"location":"api/#Next-Steps","page":"API Reference","title":"Next Steps","text":"See Examples for usage examples\nReview Compliance for specification details\nCheck User Guide for detailed explanations","category":"section"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get up and running with ToonFormat.jl.","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"Add ToonFormat.jl to your Julia environment:\n\nusing Pkg\nPkg.add(\"ToonFormat\")\n\nOr using the package manager:\n\npkg> add ToonFormat","category":"section"},{"location":"getting-started/#Development-Version","page":"Getting Started","title":"Development Version","text":"To install the latest development version:\n\nusing Pkg\nPkg.add(url=\"https://github.com/toon-format/ToonFormat.jl\")","category":"section"},{"location":"getting-started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting-started/#Encoding","page":"Getting Started","title":"Encoding","text":"Convert Julia data structures to TOON format:\n\nusing ToonFormat\n\n# Simple object\ndata = Dict(\"name\" => \"Alice\", \"age\" => 30)\ntoon_str = ToonFormat.encode(data)\nprintln(toon_str)\n# Output:\n# name: Alice\n# age: 30","category":"section"},{"location":"getting-started/#Decoding","page":"Getting Started","title":"Decoding","text":"Parse TOON format strings back to Julia data:\n\nusing ToonFormat\n\ninput = \"\"\"\nname: Alice\nage: 30\n\"\"\"\n\ndata = ToonFormat.decode(input)\n# Dict(\"name\" => \"Alice\", \"age\" => 30)","category":"section"},{"location":"getting-started/#Working-with-Arrays","page":"Getting Started","title":"Working with Arrays","text":"","category":"section"},{"location":"getting-started/#Primitive-Arrays","page":"Getting Started","title":"Primitive Arrays","text":"# Encode\nnumbers = [1, 2, 3, 4, 5]\ntoon_str = ToonFormat.encode(numbers)\nprintln(toon_str)\n# [5]: 1,2,3,4,5\n\n# Decode\ndecoded = ToonFormat.decode(\"[5]: 1,2,3,4,5\")\n# [1, 2, 3, 4, 5]","category":"section"},{"location":"getting-started/#Tabular-Arrays-(Arrays-of-Objects)","page":"Getting Started","title":"Tabular Arrays (Arrays of Objects)","text":"TOON excels at representing tabular data:\n\nusers = [\n    Dict(\"id\" => 1, \"name\" => \"Alice\", \"role\" => \"admin\"),\n    Dict(\"id\" => 2, \"name\" => \"Bob\", \"role\" => \"user\"),\n    Dict(\"id\" => 3, \"name\" => \"Charlie\", \"role\" => \"user\")\n]\n\ntoon_str = ToonFormat.encode(Dict(\"users\" => users))\nprintln(toon_str)\n# Output:\n# users[3]{id,name,role}:\n#   1,Alice,admin\n#   2,Bob,user\n#   3,Charlie,user","category":"section"},{"location":"getting-started/#Configuration-Options","page":"Getting Started","title":"Configuration Options","text":"","category":"section"},{"location":"getting-started/#Encoding-Options","page":"Getting Started","title":"Encoding Options","text":"using ToonFormat\n\n# Custom indentation (4 spaces instead of 2)\noptions = ToonFormat.EncodeOptions(indent=4)\ntoon_str = ToonFormat.encode(data, options=options)\n\n# Use tab delimiter\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\ntoon_str = ToonFormat.encode(data, options=options)\n\n# Enable key folding for nested objects\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\")\ntoon_str = ToonFormat.encode(data, options=options)","category":"section"},{"location":"getting-started/#Decoding-Options","page":"Getting Started","title":"Decoding Options","text":"using ToonFormat\n\n# Disable strict mode (lenient parsing)\noptions = ToonFormat.DecodeOptions(strict=false)\ndata = ToonFormat.decode(input, options=options)\n\n# Enable path expansion\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\")\ndata = ToonFormat.decode(input, options=options)\n\n# Custom indentation\noptions = ToonFormat.DecodeOptions(indent=4)\ndata = ToonFormat.decode(input, options=options)","category":"section"},{"location":"getting-started/#Common-Patterns","page":"Getting Started","title":"Common Patterns","text":"","category":"section"},{"location":"getting-started/#Nested-Objects","page":"Getting Started","title":"Nested Objects","text":"config = Dict(\n    \"server\" => Dict(\n        \"host\" => \"localhost\",\n        \"port\" => 8080\n    ),\n    \"database\" => Dict(\n        \"type\" => \"postgresql\",\n        \"connections\" => 10\n    )\n)\n\ntoon_str = ToonFormat.encode(config)\n# server:\n#   host: localhost\n#   port: 8080\n# database:\n#   type: postgresql\n#   connections: 10","category":"section"},{"location":"getting-started/#Mixed-Data-Types","page":"Getting Started","title":"Mixed Data Types","text":"data = Dict(\n    \"string\" => \"hello\",\n    \"number\" => 42,\n    \"boolean\" => true,\n    \"null\" => nothing,\n    \"array\" => [1, 2, 3],\n    \"object\" => Dict(\"nested\" => \"value\")\n)\n\ntoon_str = ToonFormat.encode(data)","category":"section"},{"location":"getting-started/#Error-Handling","page":"Getting Started","title":"Error Handling","text":"ToonFormat.jl provides clear error messages for invalid input:\n\nusing ToonFormat\n\n# Array count mismatch (strict mode)\ntry\n    ToonFormat.decode(\"[3]: 1,2\")  # Declares 3 items but only has 2\ncatch e\n    println(e)\n    # \"Array length mismatch: expected 3, got 2\"\nend\n\n# Invalid escape sequence\ntry\n    ToonFormat.decode(\"value: \\\"hello\\\\x\\\"\")  # \\x is not valid\ncatch e\n    println(e)\n    # \"Invalid escape sequence: \\x\"\nend","category":"section"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn more about Encoding\nLearn more about Decoding\nExplore Configuration Options\nSee Advanced Features\nBrowse Examples","category":"section"},{"location":"guide/advanced/#Advanced-Features","page":"Advanced Features","title":"Advanced Features","text":"This guide covers advanced features and use cases for ToonFormat.jl.","category":"section"},{"location":"guide/advanced/#Key-Folding-and-Path-Expansion","page":"Advanced Features","title":"Key Folding and Path Expansion","text":"Key folding and path expansion are complementary features for working with deeply nested objects.","category":"section"},{"location":"guide/advanced/#Key-Folding-(Encoding)","page":"Advanced Features","title":"Key Folding (Encoding)","text":"Flatten nested objects into dotted keys:\n\ndata = Dict(\n    \"database\" => Dict(\n        \"host\" => \"localhost\",\n        \"port\" => 5432,\n        \"credentials\" => Dict(\n            \"username\" => \"admin\",\n            \"password\" => \"secret\"\n        )\n    )\n)\n\n# Without folding\nToonFormat.encode(data)\n# database:\n#   host: localhost\n#   port: 5432\n#   credentials:\n#     username: admin\n#     password: secret\n\n# With folding\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\")\nToonFormat.encode(data, options=options)\n# database.host: localhost\n# database.port: 5432\n# database.credentials.username: admin\n# database.credentials.password: secret","category":"section"},{"location":"guide/advanced/#Path-Expansion-(Decoding)","page":"Advanced Features","title":"Path Expansion (Decoding)","text":"Expand dotted keys back into nested objects:\n\ninput = \"\"\"\ndatabase.host: localhost\ndatabase.port: 5432\ndatabase.credentials.username: admin\ndatabase.credentials.password: secret\n\"\"\"\n\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\")\ndata = ToonFormat.decode(input, options=options)\n# Dict(\"database\" => Dict(\n#     \"host\" => \"localhost\",\n#     \"port\" => 5432,\n#     \"credentials\" => Dict(\n#         \"username\" => \"admin\",\n#         \"password\" => \"secret\"\n#     )\n# ))","category":"section"},{"location":"guide/advanced/#Round-trip-Compatibility","page":"Advanced Features","title":"Round-trip Compatibility","text":"Key folding and path expansion are designed to work together:\n\noriginal = Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => 42)))\n\n# Encode with folding\nencode_opts = ToonFormat.EncodeOptions(keyFolding=\"safe\")\nencoded = ToonFormat.encode(original, options=encode_opts)\n# a.b.c: 42\n\n# Decode with expansion\ndecode_opts = ToonFormat.DecodeOptions(expandPaths=\"safe\")\ndecoded = ToonFormat.decode(encoded, options=decode_opts)\n# Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => 42)))\n\n# original == decoded ✓","category":"section"},{"location":"guide/advanced/#Conflict-Detection","page":"Advanced Features","title":"Conflict Detection","text":"Path expansion detects conflicts when keys overlap:\n\n# Conflict: 'a' is both a primitive and an object\ninput = \"\"\"\na: 1\na.b: 2\n\"\"\"\n\n# Strict mode: error\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\", strict=true)\ntry\n    ToonFormat.decode(input, options=options)\ncatch e\n    println(e)  # \"Cannot expand path 'a.b': segment 'a' already exists as non-object\"\nend\n\n# Non-strict mode: last-write-wins\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\", strict=false)\ndata = ToonFormat.decode(input, options=options)\n# Dict(\"a\" => Dict(\"b\" => 2))  # 'a: 1' is overwritten","category":"section"},{"location":"guide/advanced/#Depth-Limiting","page":"Advanced Features","title":"Depth Limiting","text":"Control how deep folding goes:\n\ndata = Dict(\"a\" => Dict(\"b\" => Dict(\"c\" => Dict(\"d\" => 42))))\n\n# Fold only 2 levels\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\", flattenDepth=2)\nToonFormat.encode(data, options=options)\n# a.b:\n#   c:\n#     d: 42","category":"section"},{"location":"guide/advanced/#Delimiter-Selection","page":"Advanced Features","title":"Delimiter Selection","text":"Choose the right delimiter for your use case.","category":"section"},{"location":"guide/advanced/#Comma-(Default)","page":"Advanced Features","title":"Comma (Default)","text":"Best for general purpose use:\n\nusers = [Dict(\"name\" => \"Alice\", \"age\" => 30)]\nToonFormat.encode(Dict(\"users\" => users))\n# users[1]{name,age}:\n#   Alice,30\n\nPros:\n\nMost compact\nFamiliar to JSON users\nWorks well with most data\n\nCons:\n\nRequires quoting if values contain commas","category":"section"},{"location":"guide/advanced/#Tab","page":"Advanced Features","title":"Tab","text":"Best for TSV-like data:\n\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\nusers = [Dict(\"name\" => \"Alice\", \"age\" => 30)]\nToonFormat.encode(Dict(\"users\" => users), options=options)\n# users[1\t]{name\tage}:\n#   Alice\t30\n\nPros:\n\nEasy to parse programmatically\nNatural for spreadsheet data\nRarely needs quoting\n\nCons:\n\nLess readable in some contexts\nInvisible character","category":"section"},{"location":"guide/advanced/#Pipe","page":"Advanced Features","title":"Pipe","text":"Best for visual separation:\n\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.PIPE)\nusers = [Dict(\"name\" => \"Alice\", \"age\" => 30)]\nToonFormat.encode(Dict(\"users\" => users), options=options)\n# users[1|]{name|age}:\n#   Alice|30\n\nPros:\n\nVery readable\nClear visual separation\nDatabase/SQL-like\n\nCons:\n\nRequires quoting if values contain pipes\nSlightly less compact","category":"section"},{"location":"guide/advanced/#Working-with-Large-Data","page":"Advanced Features","title":"Working with Large Data","text":"","category":"section"},{"location":"guide/advanced/#Streaming-Considerations","page":"Advanced Features","title":"Streaming Considerations","text":"For very large datasets, consider:\n\nChunking: Process data in smaller batches\nTabular format: Use tabular arrays for uniform data\nDelimiter choice: Tabs are fastest to parse\n\n# Process in chunks\nfunction encode_large_dataset(records, chunk_size=1000)\n    chunks = []\n    for i in 1:chunk_size:length(records)\n        chunk = records[i:min(i+chunk_size-1, length(records))]\n        push!(chunks, ToonFormat.encode(Dict(\"data\" => chunk)))\n    end\n    return chunks\nend","category":"section"},{"location":"guide/advanced/#Memory-Efficiency","page":"Advanced Features","title":"Memory Efficiency","text":"ToonFormat.jl is designed for correctness over performance, but you can optimize:\n\n# Use tabular format for uniform data (most compact)\nusers = [Dict(\"id\" => i, \"name\" => \"User$i\") for i in 1:10000]\ntoon_str = ToonFormat.encode(Dict(\"users\" => users))\n\n# Use appropriate delimiter (tabs are fastest)\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\ntoon_str = ToonFormat.encode(Dict(\"users\" => users), options=options)","category":"section"},{"location":"guide/advanced/#Custom-Indentation","page":"Advanced Features","title":"Custom Indentation","text":"Match your team's style preferences:\n\n# 2 spaces (default, most compact)\noptions = ToonFormat.EncodeOptions(indent=2)\n\n# 4 spaces (common in many languages)\noptions = ToonFormat.EncodeOptions(indent=4)\n\n# 8 spaces (very readable)\noptions = ToonFormat.EncodeOptions(indent=8)","category":"section"},{"location":"guide/advanced/#Error-Recovery","page":"Advanced Features","title":"Error Recovery","text":"Handle errors gracefully in production:\n\nfunction safe_decode(input::String)\n    try\n        # Try strict mode first\n        return ToonFormat.decode(input, options=ToonFormat.DecodeOptions(strict=true))\n    catch e\n        @warn \"Strict decoding failed, trying lenient mode\" exception=e\n        try\n            # Fall back to lenient mode\n            return ToonFormat.decode(input, options=ToonFormat.DecodeOptions(strict=false))\n        catch e2\n            @error \"Decoding failed completely\" exception=e2\n            return nothing\n        end\n    end\nend","category":"section"},{"location":"guide/advanced/#Integration-with-Other-Formats","page":"Advanced Features","title":"Integration with Other Formats","text":"","category":"section"},{"location":"guide/advanced/#From-JSON","page":"Advanced Features","title":"From JSON","text":"using JSON\n\n# JSON to TOON\njson_str = \"\"\"{\"name\": \"Alice\", \"age\": 30}\"\"\"\ndata = JSON.parse(json_str)\ntoon_str = ToonFormat.encode(data)\n\n# TOON to JSON\ntoon_str = \"name: Alice\\nage: 30\"\ndata = ToonFormat.decode(toon_str)\njson_str = JSON.json(data)","category":"section"},{"location":"guide/advanced/#From-CSV/TSV","page":"Advanced Features","title":"From CSV/TSV","text":"using CSV, DataFrames\n\n# CSV to TOON\ndf = CSV.read(\"data.csv\", DataFrame)\nrecords = [Dict(pairs(row)) for row in eachrow(df)]\ntoon_str = ToonFormat.encode(Dict(\"data\" => records))\n\n# Use tab delimiter for TSV-like output\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\ntoon_str = ToonFormat.encode(Dict(\"data\" => records), options=options)","category":"section"},{"location":"guide/advanced/#Performance-Tips","page":"Advanced Features","title":"Performance Tips","text":"Use tabular format - Most compact for uniform data\nChoose appropriate delimiter - Tabs are fastest to parse\nLimit nesting depth - Flatter structures are faster\nBatch operations - Process multiple records together\nReuse options - Create options once, reuse many times\n\n# Good: reuse options\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\nfor data in datasets\n    toon_str = ToonFormat.encode(data, options=options)\n    # process...\nend\n\n# Bad: create options every time\nfor data in datasets\n    toon_str = ToonFormat.encode(data, options=ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB))\n    # process...\nend","category":"section"},{"location":"guide/advanced/#Next-Steps","page":"Advanced Features","title":"Next Steps","text":"See Examples for real-world use cases\nCheck API Reference for complete function documentation\nReview Compliance for specification details","category":"section"},{"location":"compliance/#Specification-Compliance","page":"Compliance","title":"Specification Compliance","text":"ToonFormat.jl is fully compliant with the TOON Specification v3.0.","category":"section"},{"location":"compliance/#Validation-Status","page":"Compliance","title":"Validation Status","text":"✅ 100% Compliant - All 1750 tests passing\n\nValidation Date: November 16, 2025\nTest Suite: 1750 comprehensive tests","category":"section"},{"location":"compliance/#Requirements-Coverage","page":"Compliance","title":"Requirements Coverage","text":"All 15 normative requirements from the specification are fully implemented and tested.","category":"section"},{"location":"compliance/#1.-Data-Model-Compliance","page":"Compliance","title":"1. Data Model Compliance ✅","text":"Encodes complete JSON data model\nObjects, arrays, strings, numbers, booleans, null\nProper type normalization (NaN, Infinity → null, -0 → 0)\n\nTests: 15 test cases","category":"section"},{"location":"compliance/#2.-Number-Formatting-and-Precision","page":"Compliance","title":"2. Number Formatting and Precision ✅","text":"Canonical decimal form (no exponents)\nNo leading zeros except \"0\"\nNo trailing fractional zeros\nInteger form when fractional part is zero\nProper handling of very large/small numbers\n\nTests: 14 test cases","category":"section"},{"location":"compliance/#3.-String-Escaping-and-Quoting","page":"Compliance","title":"3. String Escaping and Quoting ✅","text":"Five valid escape sequences: \\\\, \\\", \\n, \\r, \\t\nComplete quoting rules:\nEmpty strings\nWhitespace\nReserved literals (true, false, null)\nNumeric-like strings\nSpecial characters\nDelimiter-aware quoting\n\nTests: 20 test cases","category":"section"},{"location":"compliance/#4.-Array-Header-Syntax","page":"Compliance","title":"4. Array Header Syntax ✅","text":"Proper bracket notation: [length]:\nDelimiter symbols: ,, \\t, |\nField lists for tabular arrays: {field1,field2}\nInline tabular arrays: [length]{fields}: values\n\nTests: 95 test cases","category":"section"},{"location":"compliance/#5.-Object-Encoding-and-Decoding","page":"Compliance","title":"5. Object Encoding and Decoding ✅","text":"Key-value pairs with colons\nProper indentation\nNested objects\nEmpty objects\nKey validation\n\nTests: 84 test cases","category":"section"},{"location":"compliance/#6.-Array-Format-Selection","page":"Compliance","title":"6. Array Format Selection ✅","text":"Inline format for primitive arrays\nTabular format for uniform objects\nList format for mixed content\nArrays of arrays\nProper format detection\n\nTests: 103 test cases","category":"section"},{"location":"compliance/#7.-Tabular-Array-Format","page":"Compliance","title":"7. Tabular Array Format ✅","text":"Field names from first object's keys\nOne row per object at depth +1\nRows use active delimiter\nDelimiter scoping\nRow width validation\nRow count validation\n\nTests: 98 test cases","category":"section"},{"location":"compliance/#8.-Delimiter-Scoping-and-Quoting","page":"Compliance","title":"8. Delimiter Scoping and Quoting ✅","text":"Document delimiter (comma by default)\nActive delimiter from array headers\nProper scoping for nested arrays\nDelimiter-aware quoting\nAll three delimiters supported\n\nTests: 73 test cases","category":"section"},{"location":"compliance/#9.-Indentation-and-Whitespace","page":"Compliance","title":"9. Indentation and Whitespace ✅","text":"Consistent spaces per level\nNo tabs for indentation\nExactly one space after colons\nNo trailing spaces or newlines\nStrict mode validation\n\nTests: 73 test cases","category":"section"},{"location":"compliance/#10.-Strict-Mode-Validation","page":"Compliance","title":"10. Strict Mode Validation ✅","text":"All §14 error conditions implemented:\n\nArray count mismatch (inline, list, tabular)\nRow width mismatch\nMissing colons\nInvalid escape sequences\nUnterminated strings\nIndentation errors (multiples, tabs)\nBlank lines inside arrays\nPath expansion conflicts\n\nTests: 95 test cases","category":"section"},{"location":"compliance/#11.-Root-Form-Detection","page":"Compliance","title":"11. Root Form Detection ✅","text":"Root array (first line is array header)\nSingle primitive\nRoot object (default)\nEmpty document handling\n\nTests: 48 test cases","category":"section"},{"location":"compliance/#12.-Objects-as-List-Items","page":"Compliance","title":"12. Objects as List Items ✅","text":"Proper depth handling\nEmpty objects as list items\nNested objects as list items\nMixed list items\nDeeply nested structures\n\nTests: 65 test cases","category":"section"},{"location":"compliance/#13.-Key-Folding-(Optional)","page":"Compliance","title":"13. Key Folding (Optional) ✅","text":"Safe mode (identifier keys only)\nDepth limiting\nProper dotted key generation\nWorks with arrays\nRound-trip compatible\n\nTests: 82 test cases","category":"section"},{"location":"compliance/#14.-Path-Expansion-(Optional)","page":"Compliance","title":"14. Path Expansion (Optional) ✅","text":"Safe mode (identifier segments only)\nDeep merge for overlapping paths\nConflict detection\nStrict vs non-strict behavior\nRound-trip compatible with key folding\n\nTests: 55 test cases","category":"section"},{"location":"compliance/#15.-Conformance-and-Options","page":"Compliance","title":"15. Conformance and Options ✅","text":"All encoding options work correctly\nAll decoding options work correctly\nOption combinations tested\nDefault values validated\n\nTests: 80 test cases","category":"section"},{"location":"compliance/#Additional-Test-Coverage","page":"Compliance","title":"Additional Test Coverage","text":"","category":"section"},{"location":"compliance/#Round-trip-Testing","page":"Compliance","title":"Round-trip Testing ✅","text":"Ensures encode/decode preserves values:\n\nAll primitive types\nAll object structures\nAll array formats\nComplex nested structures\nSpecial characters and escape sequences\n\nTests: 69 test cases","category":"section"},{"location":"compliance/#Determinism-Testing","page":"Compliance","title":"Determinism Testing ✅","text":"Ensures consistent output:\n\nSame input produces same output\nMultiple encodings are identical\nIdempotence verified\nOptions produce consistent results\n\nTests: 24 test cases","category":"section"},{"location":"compliance/#Edge-Cases","page":"Compliance","title":"Edge Cases ✅","text":"Comprehensive edge case coverage:\n\nEmpty values\nDeeply nested structures (10+ levels)\nLarge arrays (1000+ elements)\nSpecial characters\nNumeric boundaries\nWhitespace preservation\n\nTests: 75 test cases","category":"section"},{"location":"compliance/#Specification-Examples","page":"Compliance","title":"Specification Examples ✅","text":"All examples from the specification:\n\nBasic examples\nNumber formatting examples\nString quoting examples\nArray header examples\nDelimiter examples\nAll feature demonstrations\n\nTests: 79 test cases","category":"section"},{"location":"compliance/#Error-Conditions","page":"Compliance","title":"Error Conditions ✅","text":"All §14 error scenarios:\n\nEvery error type tested\nLine numbers in error messages\nStrict vs non-strict behavior\nClear error messages\n\nTests: 57 test cases","category":"section"},{"location":"compliance/#Test-Suite-Summary","page":"Compliance","title":"Test Suite Summary","text":"Category Tests Status\nRequirements (15 categories) 900+ ✅ All Pass\nRound-trip Testing 69 ✅ All Pass\nDeterminism Testing 24 ✅ All Pass\nEdge Cases 75 ✅ All Pass\nSpecification Examples 79 ✅ All Pass\nError Conditions 57 ✅ All Pass\nIntegration Tests 546 ✅ All Pass\nTotal 1750 ✅ All Pass","category":"section"},{"location":"compliance/#Known-Limitations","page":"Compliance","title":"Known Limitations","text":"","category":"section"},{"location":"compliance/#1.-Number-Precision","page":"Compliance","title":"1. Number Precision","text":"Limited to Float64 precision (~15-17 decimal digits)\nVery large or very small numbers may lose precision\nThis is a Julia Float64 limitation, not a ToonFormat.jl issue\n\nImpact: Minimal for most use cases","category":"section"},{"location":"compliance/#2.-Dict-Key-Order","page":"Compliance","title":"2. Dict Key Order","text":"Relies on Julia Dict preserving insertion order (Julia 1.0+)\nThis is an implementation detail, not guaranteed by language spec\nConsider using OrderedDict for guaranteed order\n\nImpact: Minimal - Julia Dicts preserve order in practice","category":"section"},{"location":"compliance/#3.-Performance","page":"Compliance","title":"3. Performance","text":"Implementation prioritizes correctness over performance\nVery deeply nested structures (100+ levels) may be slow\nLarge arrays (10,000+ elements) may impact memory usage\n\nImpact: Acceptable for most use cases","category":"section"},{"location":"compliance/#4.-Unicode","page":"Compliance","title":"4. Unicode","text":"Full UTF-8 support for string content\nSome edge cases with multi-byte characters in error messages\nNo Unicode normalization (not required by spec)\n\nImpact: Minimal - works correctly for standard UTF-8","category":"section"},{"location":"compliance/#Specification-Links","page":"Compliance","title":"Specification Links","text":"Official Specification: SPEC.md\nTest Fixtures: Spec test suite\nReference Implementation: TypeScript/JavaScript","category":"section"},{"location":"compliance/#Compliance-Verification","page":"Compliance","title":"Compliance Verification","text":"To verify compliance yourself:\n\nusing Pkg\nPkg.test(\"TOON\")\n\nThis runs the complete test suite (1750 tests) and verifies all requirements.","category":"section"},{"location":"compliance/#Next-Steps","page":"Compliance","title":"Next Steps","text":"Review API Reference for complete function documentation\nSee Examples for real-world usage\nCheck User Guide for detailed explanations","category":"section"},{"location":"guide/decoding/#Decoding-Guide","page":"Decoding Guide","title":"Decoding Guide","text":"This guide covers how to decode TOON format strings into Julia data structures.","category":"section"},{"location":"guide/decoding/#Basic-Decoding","page":"Decoding Guide","title":"Basic Decoding","text":"The decode function parses TOON format strings:\n\nusing ToonFormat\n\ndata = ToonFormat.decode(input_string)","category":"section"},{"location":"guide/decoding/#Root-Forms","page":"Decoding Guide","title":"Root Forms","text":"TOON supports three root forms:","category":"section"},{"location":"guide/decoding/#Root-Array","page":"Decoding Guide","title":"Root Array","text":"When the first line is an array header:\n\ninput = \"[3]: 1,2,3\"\nToonFormat.decode(input)  # [1, 2, 3]","category":"section"},{"location":"guide/decoding/#Root-Primitive","page":"Decoding Guide","title":"Root Primitive","text":"When the entire input is a single primitive:\n\nToonFormat.decode(\"42\")      # 42\nToonFormat.decode(\"true\")    # true\nToonFormat.decode(\"hello\")   # \"hello\"","category":"section"},{"location":"guide/decoding/#Root-Object","page":"Decoding Guide","title":"Root Object","text":"When the input contains key-value pairs (default):\n\ninput = \"\"\"\nname: Alice\nage: 30\n\"\"\"\nToonFormat.decode(input)  # Dict(\"name\" => \"Alice\", \"age\" => 30)","category":"section"},{"location":"guide/decoding/#Decoding-Arrays","page":"Decoding Guide","title":"Decoding Arrays","text":"","category":"section"},{"location":"guide/decoding/#Inline-Arrays","page":"Decoding Guide","title":"Inline Arrays","text":"ToonFormat.decode(\"[5]: 1,2,3,4,5\")\n# [1, 2, 3, 4, 5]\n\nToonFormat.decode(\"[3]: a,b,c\")\n# [\"a\", \"b\", \"c\"]","category":"section"},{"location":"guide/decoding/#Tabular-Arrays","page":"Decoding Guide","title":"Tabular Arrays","text":"input = \"\"\"\nusers[2]{id,name,role}:\n  1,Alice,admin\n  2,Bob,user\n\"\"\"\nToonFormat.decode(input)\n# Dict(\"users\" => [\n#     Dict(\"id\" => 1, \"name\" => \"Alice\", \"role\" => \"admin\"),\n#     Dict(\"id\" => 2, \"name\" => \"Bob\", \"role\" => \"user\")\n# ])","category":"section"},{"location":"guide/decoding/#List-Arrays","page":"Decoding Guide","title":"List Arrays","text":"input = \"\"\"\n[3]:\n  - 1\n  - 2\n  - 3\n\"\"\"\nToonFormat.decode(input)  # [1, 2, 3]","category":"section"},{"location":"guide/decoding/#Decoding-Options","page":"Decoding Guide","title":"Decoding Options","text":"","category":"section"},{"location":"guide/decoding/#Strict-Mode","page":"Decoding Guide","title":"Strict Mode","text":"Strict mode (enabled by default) validates the input:\n\n# Strict mode (default)\noptions = ToonFormat.DecodeOptions(strict=true)\nToonFormat.decode(input, options=options)\n\n# Non-strict mode (lenient)\noptions = ToonFormat.DecodeOptions(strict=false)\nToonFormat.decode(input, options=options)\n\nStrict mode checks:\n\nArray count matches declared length\nRow width matches field count\nNo missing colons after keys/headers\nValid escape sequences only\nNo unterminated strings\nProper indentation (multiples of indent size)\nNo tabs in indentation\nNo blank lines inside arrays","category":"section"},{"location":"guide/decoding/#Path-Expansion","page":"Decoding Guide","title":"Path Expansion","text":"Expand dotted keys into nested objects:\n\ninput = \"\"\"\napi.v1.endpoint: /api/v1\napi.v1.version: 1.0\n\"\"\"\n\noptions = ToonFormat.DecodeOptions(expandPaths=\"safe\")\nToonFormat.decode(input, options=options)\n# Dict(\"api\" => Dict(\"v1\" => Dict(\n#     \"endpoint\" => \"/api/v1\",\n#     \"version\" => \"1.0\"\n# )))","category":"section"},{"location":"guide/decoding/#Custom-Indentation","page":"Decoding Guide","title":"Custom Indentation","text":"input = \"\"\"\nuser:\n    name: Alice\n    age: 30\n\"\"\"\n\noptions = ToonFormat.DecodeOptions(indent=4)\nToonFormat.decode(input, options=options)","category":"section"},{"location":"guide/decoding/#Error-Handling","page":"Decoding Guide","title":"Error Handling","text":"ToonFormat.jl provides detailed error messages:","category":"section"},{"location":"guide/decoding/#Array-Count-Mismatch","page":"Decoding Guide","title":"Array Count Mismatch","text":"try\n    ToonFormat.decode(\"[3]: 1,2\")  # Expected 3, got 2\ncatch e\n    println(e)  # \"Array length mismatch: expected 3, got 2\"\nend","category":"section"},{"location":"guide/decoding/#Row-Width-Mismatch","page":"Decoding Guide","title":"Row Width Mismatch","text":"try\n    input = \"\"\"\n    users[2]{id,name,role}:\n      1,Alice\n      2,Bob,user\n    \"\"\"\n    ToonFormat.decode(input)\ncatch e\n    println(e)  # \"Row width mismatch at line 2: expected 3 fields, got 2\"\nend","category":"section"},{"location":"guide/decoding/#Invalid-Escape-Sequence","page":"Decoding Guide","title":"Invalid Escape Sequence","text":"try\n    ToonFormat.decode(\"value: \\\"hello\\\\x\\\"\")\ncatch e\n    println(e)  # \"Invalid escape sequence: \\x\"\nend","category":"section"},{"location":"guide/decoding/#Indentation-Errors","page":"Decoding Guide","title":"Indentation Errors","text":"try\n    input = \"\"\"\n    user:\n     name: Alice\n    \"\"\"\n    ToonFormat.decode(input)\ncatch e\n    println(e)  # \"Indentation must be a multiple of 2 spaces (line 2)\"\nend","category":"section"},{"location":"guide/decoding/#Delimiter-Detection","page":"Decoding Guide","title":"Delimiter Detection","text":"TOON automatically detects the delimiter from array headers:\n\n# Comma delimiter\nToonFormat.decode(\"[3]: 1,2,3\")\n\n# Tab delimiter\nToonFormat.decode(\"[3\\t]: 1\\t2\\t3\")\n\n# Pipe delimiter\nToonFormat.decode(\"[3|]: 1|2|3\")","category":"section"},{"location":"guide/decoding/#String-Unescaping","page":"Decoding Guide","title":"String Unescaping","text":"TOON automatically unescapes strings:\n\nToonFormat.decode(\"\\\"line1\\\\nline2\\\"\")     # \"line1\\nline2\"\nToonFormat.decode(\"\\\"tab\\\\there\\\"\")        # \"tab\\there\"\nToonFormat.decode(\"\\\"quote\\\\\\\"here\\\"\")     # \"quote\\\"here\"\nToonFormat.decode(\"\\\"backslash\\\\\\\\here\\\"\") # \"backslash\\here\"","category":"section"},{"location":"guide/decoding/#Best-Practices","page":"Decoding Guide","title":"Best Practices","text":"Use strict mode in production - Catches errors early\nHandle errors gracefully - Provide user-friendly error messages\nValidate input structure - Check for expected keys and types\nUse path expansion carefully - Only with trusted input\nMatch encoding options - Use same indent size as encoder","category":"section"},{"location":"guide/decoding/#Next-Steps","page":"Decoding Guide","title":"Next Steps","text":"Learn about Encoding\nExplore Configuration Options\nSee Advanced Features","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Real-world examples demonstrating ToonFormat.jl usage.","category":"section"},{"location":"examples/#Configuration-Files","page":"Examples","title":"Configuration Files","text":"","category":"section"},{"location":"examples/#Application-Config","page":"Examples","title":"Application Config","text":"using ToonFormat\n\nconfig = Dict(\n    \"app\" => Dict(\n        \"name\" => \"MyApp\",\n        \"version\" => \"1.0.0\",\n        \"debug\" => false\n    ),\n    \"server\" => Dict(\n        \"host\" => \"0.0.0.0\",\n        \"port\" => 8080,\n        \"workers\" => 4\n    ),\n    \"database\" => Dict(\n        \"type\" => \"postgresql\",\n        \"host\" => \"localhost\",\n        \"port\" => 5432,\n        \"name\" => \"myapp_db\"\n    ),\n    \"logging\" => Dict(\n        \"level\" => \"info\",\n        \"file\" => \"/var/log/myapp.log\"\n    )\n)\n\n# Encode to TOON\ntoon_str = ToonFormat.encode(config)\nprintln(toon_str)\n\n# With key folding for flatter structure\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\", flattenDepth=2)\ntoon_str = ToonFormat.encode(config, options=options)\nprintln(toon_str)","category":"section"},{"location":"examples/#Data-Processing","page":"Examples","title":"Data Processing","text":"","category":"section"},{"location":"examples/#User-Records","page":"Examples","title":"User Records","text":"using ToonFormat\n\nusers = [\n    Dict(\"id\" => 1, \"name\" => \"Alice\", \"email\" => \"alice@example.com\", \"active\" => true),\n    Dict(\"id\" => 2, \"name\" => \"Bob\", \"email\" => \"bob@example.com\", \"active\" => true),\n    Dict(\"id\" => 3, \"name\" => \"Charlie\", \"email\" => \"charlie@example.com\", \"active\" => false)\n]\n\n# Encode as tabular data (very compact)\ntoon_str = ToonFormat.encode(Dict(\"users\" => users))\nprintln(toon_str)\n# users[3]{id,name,email,active}:\n#   1,Alice,alice@example.com,true\n#   2,Bob,bob@example.com,true\n#   3,Charlie,charlie@example.com,false\n\n# Save to file\nwrite(\"users.toon\", toon_str)\n\n# Load from file\nloaded_str = read(\"users.toon\", String)\ndata = ToonFormat.decode(loaded_str)","category":"section"},{"location":"examples/#Time-Series-Data","page":"Examples","title":"Time Series Data","text":"using ToonFormat, Dates\n\n# Generate time series data\ntimestamps = [DateTime(2024, 1, 1) + Hour(i) for i in 0:23]\ntemperatures = [20.0 + 5 * sin(i * π / 12) for i in 0:23]\n\ndata = [\n    Dict(\"time\" => string(t), \"temp\" => round(temp, digits=1))\n    for (t, temp) in zip(timestamps, temperatures)\n]\n\n# Encode with tab delimiter for TSV-like format\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\ntoon_str = ToonFormat.encode(Dict(\"readings\" => data), options=options)\nprintln(toon_str)","category":"section"},{"location":"examples/#API-Responses","page":"Examples","title":"API Responses","text":"","category":"section"},{"location":"examples/#REST-API-Response","page":"Examples","title":"REST API Response","text":"using ToonFormat\n\nresponse = Dict(\n    \"status\" => \"success\",\n    \"code\" => 200,\n    \"data\" => Dict(\n        \"user\" => Dict(\n            \"id\" => 123,\n            \"username\" => \"alice\",\n            \"email\" => \"alice@example.com\",\n            \"profile\" => Dict(\n                \"firstName\" => \"Alice\",\n                \"lastName\" => \"Smith\",\n                \"age\" => 30\n            )\n        ),\n        \"permissions\" => [\"read\", \"write\", \"admin\"]\n    ),\n    \"meta\" => Dict(\n        \"timestamp\" => \"2024-01-01T12:00:00Z\",\n        \"requestId\" => \"abc-123-def\"\n    )\n)\n\n# Encode for LLM context (compact)\ntoon_str = ToonFormat.encode(response)\nprintln(toon_str)\n\n# Token count comparison\nusing JSON\njson_str = JSON.json(response)\nprintln(\"JSON length: $(length(json_str))\")\nprintln(\"TOON length: $(length(toon_str))\")\nprintln(\"Reduction: $(round((1 - length(toon_str)/length(json_str)) * 100, digits=1))%\")","category":"section"},{"location":"examples/#Paginated-Results","page":"Examples","title":"Paginated Results","text":"using ToonFormat\n\nresults = Dict(\n    \"page\" => 1,\n    \"perPage\" => 10,\n    \"total\" => 100,\n    \"items\" => [\n        Dict(\"id\" => i, \"title\" => \"Item $i\", \"price\" => 10.0 * i)\n        for i in 1:10\n    ],\n    \"links\" => Dict(\n        \"self\" => \"/api/items?page=1\",\n        \"next\" => \"/api/items?page=2\",\n        \"last\" => \"/api/items?page=10\"\n    )\n)\n\ntoon_str = ToonFormat.encode(results)\nprintln(toon_str)","category":"section"},{"location":"examples/#Machine-Learning","page":"Examples","title":"Machine Learning","text":"","category":"section"},{"location":"examples/#Training-Data","page":"Examples","title":"Training Data","text":"using ToonFormat\n\n# Training examples\ntraining_data = [\n    Dict(\"features\" => [1.0, 2.0, 3.0], \"label\" => 0),\n    Dict(\"features\" => [2.0, 3.0, 4.0], \"label\" => 1),\n    Dict(\"features\" => [3.0, 4.0, 5.0], \"label\" => 1)\n]\n\n# Encode for storage\ntoon_str = ToonFormat.encode(Dict(\"training\" => training_data))\nwrite(\"training.toon\", toon_str)\n\n# Load for training\nloaded = ToonFormat.decode(read(\"training.toon\", String))\nX = hcat([d[\"features\"] for d in loaded[\"training\"]]...)'\ny = [d[\"label\"] for d in loaded[\"training\"]]","category":"section"},{"location":"examples/#Model-Metadata","page":"Examples","title":"Model Metadata","text":"using ToonFormat\n\nmetadata = Dict(\n    \"model\" => Dict(\n        \"type\" => \"neural_network\",\n        \"architecture\" => \"feedforward\",\n        \"layers\" => [\n            Dict(\"type\" => \"dense\", \"units\" => 128, \"activation\" => \"relu\"),\n            Dict(\"type\" => \"dropout\", \"rate\" => 0.2),\n            Dict(\"type\" => \"dense\", \"units\" => 64, \"activation\" => \"relu\"),\n            Dict(\"type\" => \"dense\", \"units\" => 10, \"activation\" => \"softmax\")\n        ]\n    ),\n    \"training\" => Dict(\n        \"optimizer\" => \"adam\",\n        \"learningRate\" => 0.001,\n        \"batchSize\" => 32,\n        \"epochs\" => 100\n    ),\n    \"metrics\" => Dict(\n        \"accuracy\" => 0.95,\n        \"loss\" => 0.15,\n        \"valAccuracy\" => 0.93,\n        \"valLoss\" => 0.18\n    )\n)\n\ntoon_str = ToonFormat.encode(metadata)\nprintln(toon_str)","category":"section"},{"location":"examples/#Database-Export","page":"Examples","title":"Database Export","text":"","category":"section"},{"location":"examples/#Query-Results","page":"Examples","title":"Query Results","text":"using ToonFormat\n\n# Simulated database query results\nquery_results = [\n    Dict(\"id\" => 1, \"name\" => \"Product A\", \"price\" => 29.99, \"stock\" => 100),\n    Dict(\"id\" => 2, \"name\" => \"Product B\", \"price\" => 49.99, \"stock\" => 50),\n    Dict(\"id\" => 3, \"name\" => \"Product C\", \"price\" => 19.99, \"stock\" => 200)\n]\n\n# Export with pipe delimiter (database-style)\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.PIPE)\ntoon_str = ToonFormat.encode(Dict(\"products\" => query_results), options=options)\nprintln(toon_str)\n# products[3|]{id|name|price|stock}:\n#   1|Product A|29.99|100\n#   2|Product B|49.99|50\n#   3|Product C|19.99|200","category":"section"},{"location":"examples/#LLM-Context","page":"Examples","title":"LLM Context","text":"","category":"section"},{"location":"examples/#Prompt-with-Data","page":"Examples","title":"Prompt with Data","text":"using ToonFormat\n\n# Prepare data for LLM prompt\ncontext_data = Dict(\n    \"user\" => Dict(\n        \"name\" => \"Alice\",\n        \"preferences\" => [\"sci-fi\", \"mystery\"],\n        \"readBooks\" => 42\n    ),\n    \"recommendations\" => [\n        Dict(\"title\" => \"Dune\", \"author\" => \"Frank Herbert\", \"genre\" => \"sci-fi\"),\n        Dict(\"title\" => \"Foundation\", \"author\" => \"Isaac Asimov\", \"genre\" => \"sci-fi\"),\n        Dict(\"title\" => \"The Martian\", \"author\" => \"Andy Weir\", \"genre\" => \"sci-fi\")\n    ]\n)\n\n# Encode for LLM context\ntoon_str = ToonFormat.encode(context_data)\n\n# Build prompt\nprompt = \"\"\"\nBased on the following user data, suggest additional books:\n\n$toon_str\n\nPlease provide 3 more recommendations.\n\"\"\"\n\nprintln(prompt)","category":"section"},{"location":"examples/#Testing","page":"Examples","title":"Testing","text":"","category":"section"},{"location":"examples/#Test-Fixtures","page":"Examples","title":"Test Fixtures","text":"using ToonFormat, Test\n\n# Define test fixtures in TOON format\nfixtures_toon = \"\"\"\nusers[3]{id,name,role}:\n  1,Alice,admin\n  2,Bob,user\n  3,Charlie,user\nsettings:\n  theme: dark\n  notifications: true\n\"\"\"\n\n# Load fixtures\nfixtures = ToonFormat.decode(fixtures_toon)\n\n# Use in tests\n@testset \"User Tests\" begin\n    users = fixtures[\"users\"]\n    @test length(users) == 3\n    @test users[1][\"name\"] == \"Alice\"\n    @test users[1][\"role\"] == \"admin\"\nend","category":"section"},{"location":"examples/#Data-Migration","page":"Examples","title":"Data Migration","text":"","category":"section"},{"location":"examples/#Format-Conversion","page":"Examples","title":"Format Conversion","text":"using ToonFormat, JSON\n\n# Convert JSON to TOON\nfunction json_to_toon(json_file, toon_file; options=ToonFormat.EncodeOptions())\n    data = JSON.parsefile(json_file)\n    toon_str = ToonFormat.encode(data, options=options)\n    write(toon_file, toon_str)\nend\n\n# Convert TOON to JSON\nfunction toon_to_json(toon_file, json_file)\n    toon_str = read(toon_file, String)\n    data = ToonFormat.decode(toon_str)\n    json_str = JSON.json(data, 2)  # Pretty print with 2-space indent\n    write(json_file, json_str)\nend\n\n# Usage\njson_to_toon(\"data.json\", \"data.toon\", options=ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB))\ntoon_to_json(\"data.toon\", \"data_converted.json\")","category":"section"},{"location":"examples/#Next-Steps","page":"Examples","title":"Next Steps","text":"Review API Reference for complete function documentation\nCheck Compliance for specification details\nSee User Guide for detailed explanations","category":"section"},{"location":"guide/encoding/#Encoding-Guide","page":"Encoding Guide","title":"Encoding Guide","text":"This guide covers how to encode Julia data structures into TOON format.","category":"section"},{"location":"guide/encoding/#Basic-Encoding","page":"Encoding Guide","title":"Basic Encoding","text":"The encode function converts Julia values to TOON format strings:\n\nusing ToonFormat\n\nresult = ToonFormat.encode(value)","category":"section"},{"location":"guide/encoding/#Primitive-Types","page":"Encoding Guide","title":"Primitive Types","text":"","category":"section"},{"location":"guide/encoding/#Numbers","page":"Encoding Guide","title":"Numbers","text":"Numbers are encoded in canonical decimal form:\n\nToonFormat.encode(42)           # \"42\"\nToonFormat.encode(3.14)         # \"3.14\"\nToonFormat.encode(-0.5)         # \"-0.5\"\nToonFormat.encode(1000000)      # \"1000000\"\n\nRules:\n\nNo exponential notation\nNo leading zeros (except \"0\")\nNo trailing zeros in fractional part\nInteger form when fractional part is zero\n-0 is normalized to 0","category":"section"},{"location":"guide/encoding/#Strings","page":"Encoding Guide","title":"Strings","text":"Strings are quoted only when necessary:\n\nToonFormat.encode(\"hello\")      # \"hello\"\nToonFormat.encode(\"hello world\") # \"\\\"hello world\\\"\"  (contains space)\nToonFormat.encode(\"\")           # \"\\\"\\\"\"  (empty string)\nToonFormat.encode(\"true\")       # \"\\\"true\\\"\"  (reserved literal)\nToonFormat.encode(\"123\")        # \"\\\"123\\\"\"  (numeric-like)\n\nQuoting rules:\n\nEmpty strings must be quoted\nStrings with whitespace must be quoted\nReserved literals (true, false, null) must be quoted\nNumeric-like strings must be quoted\nStrings with special characters must be quoted","category":"section"},{"location":"guide/encoding/#Booleans-and-Null","page":"Encoding Guide","title":"Booleans and Null","text":"ToonFormat.encode(true)         # \"true\"\nToonFormat.encode(false)        # \"false\"\nToonFormat.encode(nothing)      # \"null\"","category":"section"},{"location":"guide/encoding/#Objects","page":"Encoding Guide","title":"Objects","text":"Objects are encoded as key-value pairs with proper indentation:\n\ndata = Dict(\n    \"name\" => \"Alice\",\n    \"age\" => 30,\n    \"active\" => true\n)\n\nToonFormat.encode(data)\n# name: Alice\n# age: 30\n# active: true","category":"section"},{"location":"guide/encoding/#Nested-Objects","page":"Encoding Guide","title":"Nested Objects","text":"data = Dict(\n    \"user\" => Dict(\n        \"name\" => \"Alice\",\n        \"email\" => \"alice@example.com\"\n    ),\n    \"settings\" => Dict(\n        \"theme\" => \"dark\",\n        \"notifications\" => true\n    )\n)\n\nToonFormat.encode(data)\n# user:\n#   name: Alice\n#   email: alice@example.com\n# settings:\n#   theme: dark\n#   notifications: true","category":"section"},{"location":"guide/encoding/#Arrays","page":"Encoding Guide","title":"Arrays","text":"TOON supports three array formats depending on the content.","category":"section"},{"location":"guide/encoding/#Inline-Arrays-(Primitives)","page":"Encoding Guide","title":"Inline Arrays (Primitives)","text":"Arrays of primitives are encoded inline:\n\nToonFormat.encode([1, 2, 3, 4, 5])\n# [5]: 1,2,3,4,5\n\nToonFormat.encode([\"a\", \"b\", \"c\"])\n# [3]: a,b,c\n\nToonFormat.encode([true, false, true])\n# [3]: true,false,true","category":"section"},{"location":"guide/encoding/#Tabular-Arrays-(Uniform-Objects)","page":"Encoding Guide","title":"Tabular Arrays (Uniform Objects)","text":"Arrays of objects with the same keys use tabular format:\n\nusers = [\n    Dict(\"id\" => 1, \"name\" => \"Alice\", \"role\" => \"admin\"),\n    Dict(\"id\" => 2, \"name\" => \"Bob\", \"role\" => \"user\")\n]\n\nToonFormat.encode(Dict(\"users\" => users))\n# users[2]{id,name,role}:\n#   1,Alice,admin\n#   2,Bob,user\n\nBenefits:\n\nExtremely compact for tabular data\nClear column structure\nEasy to read and edit","category":"section"},{"location":"guide/encoding/#List-Arrays-(Mixed-Content)","page":"Encoding Guide","title":"List Arrays (Mixed Content)","text":"Arrays with mixed types or non-uniform objects use list format:\n\nmixed = [\n    Dict(\"type\" => \"user\", \"name\" => \"Alice\"),\n    Dict(\"type\" => \"admin\", \"name\" => \"Bob\", \"level\" => 5),\n    42,\n    \"string value\"\n]\n\nToonFormat.encode(mixed)\n# [4]:\n#   - type: user\n#     name: Alice\n#   - type: admin\n#     name: Bob\n#     level: 5\n#   - 42\n#   - string value","category":"section"},{"location":"guide/encoding/#Arrays-of-Arrays","page":"Encoding Guide","title":"Arrays of Arrays","text":"Nested arrays are encoded as list items:\n\nmatrix = [[1, 2], [3, 4], [5, 6]]\n\nToonFormat.encode(matrix)\n# [3]:\n#   - [2]: 1,2\n#   - [2]: 3,4\n#   - [2]: 5,6","category":"section"},{"location":"guide/encoding/#Encoding-Options","page":"Encoding Guide","title":"Encoding Options","text":"","category":"section"},{"location":"guide/encoding/#Custom-Indentation","page":"Encoding Guide","title":"Custom Indentation","text":"options = ToonFormat.EncodeOptions(indent=4)\nToonFormat.encode(data, options=options)","category":"section"},{"location":"guide/encoding/#Delimiter-Selection","page":"Encoding Guide","title":"Delimiter Selection","text":"Choose between comma, tab, or pipe delimiters:\n\n# Comma (default)\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.COMMA)\n\n# Tab\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.TAB)\n\n# Pipe\noptions = ToonFormat.EncodeOptions(delimiter=ToonFormat.PIPE)\n\nusers = [Dict(\"name\" => \"Alice\", \"age\" => 30)]\nToonFormat.encode(Dict(\"users\" => users), options=options)\n# With pipe: users[1|]{name|age}:\n#              Alice|30","category":"section"},{"location":"guide/encoding/#Key-Folding","page":"Encoding Guide","title":"Key Folding","text":"Flatten nested objects into dotted keys:\n\ndata = Dict(\n    \"api\" => Dict(\n        \"v1\" => Dict(\n            \"endpoint\" => \"/api/v1\"\n        )\n    )\n)\n\n# Without key folding (default)\nToonFormat.encode(data)\n# api:\n#   v1:\n#     endpoint: /api/v1\n\n# With key folding\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\")\nToonFormat.encode(data, options=options)\n# api.v1.endpoint: /api/v1\n\nFlatten depth limit:\n\noptions = ToonFormat.EncodeOptions(keyFolding=\"safe\", flattenDepth=2)\nToonFormat.encode(data, options=options)\n# api.v1:\n#   endpoint: /api/v1","category":"section"},{"location":"guide/encoding/#Special-Cases","page":"Encoding Guide","title":"Special Cases","text":"","category":"section"},{"location":"guide/encoding/#Empty-Values","page":"Encoding Guide","title":"Empty Values","text":"ToonFormat.encode(Dict())       # \"{}\"\nToonFormat.encode([])           # \"[]\"\nToonFormat.encode(\"\")           # \"\\\"\\\"\"","category":"section"},{"location":"guide/encoding/#Special-Numbers","page":"Encoding Guide","title":"Special Numbers","text":"ToonFormat.encode(NaN)          # \"null\"  (normalized)\nToonFormat.encode(Inf)          # \"null\"  (normalized)\nToonFormat.encode(-Inf)         # \"null\"  (normalized)\nToonFormat.encode(-0.0)         # \"0\"     (normalized)","category":"section"},{"location":"guide/encoding/#Escape-Sequences","page":"Encoding Guide","title":"Escape Sequences","text":"Five escape sequences are supported:\n\nToonFormat.encode(\"line1\\nline2\")        # \"\\\"line1\\\\nline2\\\"\"\nToonFormat.encode(\"tab\\there\")           # \"\\\"tab\\\\there\\\"\"\nToonFormat.encode(\"quote\\\"here\")         # \"\\\"quote\\\\\\\"here\\\"\"\nToonFormat.encode(\"backslash\\\\here\")     # \"\\\"backslash\\\\\\\\here\\\"\"\nToonFormat.encode(\"return\\rhere\")        # \"\\\"return\\\\rhere\\\"\"","category":"section"},{"location":"guide/encoding/#Best-Practices","page":"Encoding Guide","title":"Best Practices","text":"Use tabular format for uniform data - It's the most compact\nChoose appropriate delimiters - Tabs for TSV-like data, pipes for visual separation\nEnable key folding for deep nesting - Reduces indentation levels\nLimit flatten depth - Prevents over-flattening of complex structures\nNormalize data before encoding - Ensure consistent structure for tabular arrays","category":"section"},{"location":"guide/encoding/#Next-Steps","page":"Encoding Guide","title":"Next Steps","text":"Learn about Decoding\nExplore Configuration Options\nSee Advanced Features","category":"section"},{"location":"#ToonFormat.jl","page":"Home","title":"ToonFormat.jl","text":"(Image: SPEC v3.0)\n\nJulia implementation of Token-Oriented Object Notation (TOON), a compact, human-readable serialization format optimized for LLM contexts.\n\n✅ Fully compliant with TOON Specification v3.0 - All 1750 tests passing","category":"section"},{"location":"#What-is-TOON?","page":"Home","title":"What is TOON?","text":"TOON is a line-oriented, indentation-based text format that encodes the JSON data model with explicit structure and minimal quoting. It achieves 30-60% token reduction compared to JSON while maintaining readability and deterministic structure.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Compact tabular data - Efficient representation of arrays of objects\nMinimal quoting - Smart quoting rules reduce visual noise\nExplicit array lengths - Built-in validation for data integrity\nMultiple delimiters - Comma, tab, and pipe support\nStrict mode - Optional validation for production use\n100% JSON compatible - Encodes the complete JSON data model","category":"section"},{"location":"#Why-TOON?","page":"Home","title":"Why TOON?","text":"When working with Large Language Models, token efficiency matters. TOON provides:\n\nReduced token costs - 30-60% fewer tokens than JSON\nBetter readability - Cleaner syntax for humans and LLMs\nValidation - Explicit lengths catch errors early\nFlexibility - Multiple delimiters for different use cases","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"JSON (156 tokens):\n\n{\n  \"users\": [\n    { \"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\", \"active\": true },\n    { \"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\", \"active\": false }\n  ],\n  \"count\": 2\n}\n\nTOON (89 tokens - 43% reduction):\n\nusers[2]{id,name,email,active}:\n  1,Alice,alice@example.com,true\n  2,Bob,bob@example.com,false\ncount: 2","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"ToonFormat\")\n\nOr in the Julia REPL package mode:\n\npkg> add ToonFormat","category":"section"},{"location":"#Development-Version","page":"Home","title":"Development Version","text":"To install the latest development version:\n\nusing Pkg\nPkg.add(url=\"https://github.com/toon-format/ToonFormat.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using ToonFormat\n\n# Encode Julia data to TOON\ndata = Dict(\"name\" => \"Alice\", \"age\" => 30)\ntoon_str = ToonFormat.encode(data)\nprintln(toon_str)\n# name: Alice\n# age: 30\n\n# Decode TOON to Julia data\ndecoded = ToonFormat.decode(toon_str)\n# Dict(\"name\" => \"Alice\", \"age\" => 30)","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"Getting Started - Installation and basic usage\nUser Guide - Detailed encoding and decoding guide\nExamples - Real-world usage examples\nAPI Reference - Complete API documentation\nCompliance - Specification compliance details","category":"section"}]
}
